#!groovy
@Library(['global-pipeline-library@release/v9.1',
          'security-library@release/v2.0'])_

import com.mapfre.pod.Container
import com.mapfre.pod.ContainerType
import com.mapfre.pod.ContainerTypeCustom
import com.mapfre.pod.ContainerSize

//NOMBRE DE TU ORGANIZACION
def DEVOPS_PLATFORM_ORGANIZATION = 'org-mapfrebrasil'

pipeline {

  //Use especific container for  custom agent.
  agent {
        kubernetes {
           yaml getPodTemplate(DEVOPS_PLATFORM_ORGANIZATION,[
                    ['cdk', new ContainerTypeCustom('acrmapfredevops.azurecr.io/mapfre/global/mapfrecdk:1.0.33', 'Always', 'cat'), ContainerSize.LARGE], 
                    ['sonar-scanner-cli', ContainerType.SONAR_SCANNER_CLI_STABLE, ContainerSize.EXTRA_LARGE],
                    ['azure-cli', ContainerType.AZURE_CLI_STABLE, ContainerSize.LARGE]
            ] as Container[], true)
        }
  }


  environment {         
        ENVIRONMENT=getSynthEnv()   
        PACKAGE_NAME= 'bff-package'
        SONAR_ENVIRONMENT           = 'MAR2-SONAR-PRO'     // Nombre dado en la configurcion de Jenkins a ese Sonar Server
        SONAR_TOKEN                 = 'mar2-sonar-token' // Credential ID del token de Sonar generado por equipo QA
        SONAR_PROJECT_NAME          = 'BIB_MAR2_APPMARBACKEND.develop'
        SONAR_PROJECT_KEY           = 'MAR2_APPMARBACKEND.develop'       
  }
  
  options {
        timeout(time: 25, unit: 'MINUTES')
        timestamps()

        azureKeyVault(
          secrets: [
            [envVariable: 'AWS-ACCESS-KEY-ID-' + getIdProduct() + '-' + getSynthEnv(), name: 'AWS-ACCESS-KEY-ID-' + getIdProduct() + '-' + getSynthEnv(), secretType: 'Secret'],
            [envVariable: 'AWS-SECRET-ACCESS-KEY-' + getIdProduct() + '-' + getSynthEnv(), name: 'AWS-SECRET-ACCESS-KEY-' + getIdProduct() + '-' + getSynthEnv(), secretType: 'Secret'],
            [envVariable: 'ACCOUNTID', name: 'AWS-ACCOUNT-ID-' + getIdProduct() + '-' + getSynthEnv(), secretType: 'Secret'],
            [envVariable: 'REGION', name: 'AWS-REGION-' + getIdProduct() + '-' + getSynthEnv(), secretType: 'Secret'],
          ]
        )
  }


  

  stages {

    stage('ðŸ”§ Prepare ') {
      steps {     
          //Aws login and token for Azure Artifacts
          script {
                container('cdk'){
                    awsLogin(ACCOUNTID,'AWS-ACCESS-KEY-ID-' + getIdProduct() + '-' + getSynthEnv(),'AWS-SECRET-ACCESS-KEY-' + getIdProduct() + '-' + getSynthEnv(),REGION)
                    
                    def secrets = [
                        secret("app-user-azure-artifacts-username", 'v_pass')
                    ]
                    withKeyVaultSecret(secrets) {
                        env.BASE64_ENCODED_PERSONAL_ACCESS_TOKEN = "${v_pass}"
                    }
                }
          }
      }
    }


    stage('Security pre-build'){
      steps{
            script{
                  secPreBuild()
            }
      }
    }
    
   
    
    stage('sonar analysis'){
        when{
              anyOf{
                    branch 'master'; branch 'develop' ; branch 'release'; branch 'hotfix';  branch 'homolog'
              }
        }  
        steps {
              container('sonar-scanner-cli'){
                    script{
                          sonarScanner(SONAR_ENVIRONMENT, SONAR_TOKEN, SONAR_PROJECT_KEY, SONAR_PROJECT_NAME)            
                    }        
              }
        }
    }
    stage('SonarQube Quality Gates') {
        when{
              anyOf{
                    branch 'master'; branch 'develop' ; branch 'release' ; branch 'hotfix';  branch 'homolog'
              }
        }           
        steps {
              script{
              
                    sonar_url = getSonarAnalysisURL(SONAR_ENVIRONMENT, SONAR_PROJECT_KEY)
                    echo "Sonar Analysis: ${sonar_url}"

                    getSonarAnalysisPDF(SONAR_ENVIRONMENT, SONAR_PROJECT_KEY)
                    fileNameSonarEvidence = "SonarEvidencesZip.zip"
                    zip zipFile: './' + fileNameSonarEvidence, archive: true, dir: './', glob: '*.pdf'

                    sonarStatus = checkQualityGates(SONAR_ENVIRONMENT, SONAR_PROJECT_KEY) 
                    if (sonarStatus!="OK"){
                          error "Quality Gates: ${sonarStatus}"   
                    }
              } 
        }
    }        
   
  
   stage('Build') {
      steps {
        container('cdk'){
            npmInstall();
            // sh """
            //   npm run build              
            // """
        }
      }
    }

    /*stage('Test') {
      steps {
        container('cdk'){
           script{       
            sh """            
            npm test         
            """    
          }
        }       
      }
    }*/

   
    stage('Validate Aspects') {
      steps {
        container('cdk'){
            script{            
              validateAspects()
          }
        }
      }
    }

        
    stage('Synthesize CDK ðŸš€') {
      steps {
        container('cdk'){
          script{             
            cdkSynth()
          }
        }
      }
    }
    
  
    stage('ðŸ”’ Security post-build'){
      steps {
        script{
          secPostBuild()
        }
      }
    }


    stage('Publish Snapshot'){       
      when{
        anyOf{
          branch 'develop'; 
        }
      }  
      steps {
            script{
                def secrets = [
                    secret("app-user-azure-artifacts-password",'pat')
                ]

                 sh 'mkdir dist'
                //sh 'mkdir ./tmp/sources/api-contract; mkdir ./tmp/sources/config;cp ./sources/api-contract/*  ./tmp/sources/api-contract; cp ./sources/config/* ./tmp/sources/config'
                zip dir: '.', exclude: 'node_modules/,cdk.out/,cdk.context.json,test/,docs/,cicd/,eslint/,coverage/,eslintrc.json,.gitignore,catalog-info.yaml,COVERAGE.md,jest.config.js,mkdocs.yml,template.yaml', glob: '', zipFile: 'dist/backend.zip'
                                             
                withKeyVaultSecret(secrets) { 
                    universalPackagePublish('snapshots', PACKAGE_NAME, getversion('package.json') + "-snapshot-" + env.BUILD_ID, 'dist', pat,"Snapshot backend Archetype library to deploy")                    
                }

            }
          }
    }

    stage('Publish Release Candidate'){

      when{
        anyOf{
          branch 'releases/*';  branch 'release' 
        }
      }  

      steps {
            script{
                def secrets = [
                    secret("app-user-azure-artifacts-password",'pat')
                ]

                 sh 'mkdir dist'
                //sh 'mkdir ./tmp/sources/api-contract; mkdir ./tmp/sources/config;cp ./sources/api-contract/*  ./tmp/sources/api-contract; cp ./sources/config/* ./tmp/sources/config'
                zip dir: '.', exclude: 'node_modules/,cdk.out/,cdk.context.json,test/,docs/,cicd/,eslint/,coverage/,eslintrc.json,.gitignore,catalog-info.yaml,COVERAGE.md,jest.config.js,mkdocs.yml,template.yaml', glob: '', zipFile: 'dist/backend.zip'
                
                withKeyVaultSecret(secrets) { 
                    universalPackagePublish('releases', PACKAGE_NAME, getversion ('package.json') + '-rc-' + env.BUILD_ID , 'dist', pat,"Release Candidate backend Archetype library to deploy")                    
                }

                gitTag(getversion ('package.json') + '-rc-' + env.BUILD_ID,'Release Candidate backend Archetype library to deploy: '+getversion ('package.json') + '-rc-' + env.BUILD_ID)
                gitPushTags()

            }
          }
    }


    stage('Publish hotfix'){

       when{
        anyOf{
          branch 'hotfix/*'; 
        }
      }  

      steps {
            script{
                def secrets = [
                    secret("app-user-azure-artifacts-password",'pat')
                ]

                sh 'mkdir dist'
                //sh 'mkdir ./tmp/sources/api-contract; mkdir ./tmp/sources/config;cp ./sources/api-contract/*  ./tmp/sources/api-contract; cp ./sources/config/* ./tmp/sources/config'
                zip dir: '.', exclude: 'node_modules/,cdk.out/,cdk.context.json,test/,docs/,cicd/,eslint/,coverage/,eslintrc.json,.gitignore,catalog-info.yaml,COVERAGE.md,jest.config.js,mkdocs.yml,template.yaml', glob: '', zipFile: 'dist/backend.zip'
              
                withKeyVaultSecret(secrets) { 
                    universalPackagePublish('release', PACKAGE_NAME, getversion ('package.json') + '-hf-' + env.BUILD_ID, 'dist', pat,"HotFix backend Archetype library to deploy")                    
                }

                gitTag(getversion ('package.json') + '-hf-' + env.BUILD_ID,'HotFix backend Archetype library to deploy: '+getversion ('package.json') + '-hf-' + env.BUILD_ID)
                gitPushTags()

            }
          }
    }
    
    stage('Publish Release '){

      when{
        anyOf{
          branch 'master'
        }
      }  

      steps {
            script{
                def secrets = [
                    secret("app-user-azure-artifacts-password",'pat')
                ]

                sh 'mkdir dist'
                //sh 'mkdir ./tmp/sources/api-contract; mkdir ./tmp/sources/config;cp ./sources/api-contract/*  ./tmp/sources/api-contract; cp ./sources/config/* ./tmp/sources/config'
                zip dir: '.', exclude: 'node_modules/,cdk.out/,cdk.context.json,test/,docs/,cicd/,eslint/,coverage/,eslintrc.json,.gitignore,catalog-info.yaml,COVERAGE.md,jest.config.js,mkdocs.yml,template.yaml', glob: '', zipFile: 'dist/backend.zip'
                
                
                withKeyVaultSecret(secrets) { 
                    universalPackagePublish('releases', PACKAGE_NAME, getversion ('package.json') , 'dist', pat,"Release backend Archetype library to deploy")                           
                }

                gitTag(getversion ('package.json'),'Release backend Archetype library to deploy: '+getversion ('package.json') )               
                gitPushTags()      

            }
          }
    }


     stage('ðŸ”’ Security pre-deploy'){
      when{
        anyOf{
          branch 'develop';
        }
      }

      steps {
            script{
                  secPreDeploy()
            }
      }
    }

    
    //Deploy snapshot only for develop branch and only to INT environments
    stage('ðŸš€ Deploy Snapshot from artifacts'){

      when{
        anyOf{
          branch 'develop';
        }
      }
     
      steps {
            script{
              def secrets = [
                  secret("app-user-azure-artifacts-password",'pat')
              ]              

              container('cdk'){    

                  withKeyVaultSecret(secrets) {  

                      universalPackageDownload('snapshots', PACKAGE_NAME, getversion ('package.json') + "-snapshot-" + env.BUILD_ID, '.', pat)


                  }
              
                
                  unzip zipFile: 'backend.zip', dir: './deploy'  

                  //Install dependencies    
                  dir("deploy"){
                    npmInstall()
                    //sleep 60
                  }

                  sh """
                        cd ./deploy            
                        cdk bootstrap -c env=$ENVIRONMENT --all 
                        cdk deploy -c env=$ENVIRONMENT --all --require-approval never 
                  """    

                 

              }                  

          }
      }      

    }
    

    // This is a security stage that must be executed after deploying any image or application.

    
    stage('ðŸ”’ Security post-deploy'){
      
      when{
        anyOf{
          branch 'develop';
        }
      }

      steps{
            script{
                  secPostDeploy()
            }
      }
    }


      
  }

   post {
      always {
          echo '--always--'
          showStageStatus()
          //logstashSend failBuild: false, maxLines: 150000
      }
      success {
          echo '--success--'
      }
      failure {
          echo '--failure--'
          script {
            GIT_COMMIT_EMAIL = sh (
              script: 'git --no-pager show -s --format=\'%ae\'',
              returnStdout: true
            ).trim()
          }
          echo "TARGET ${GIT_COMMIT_EMAIL}"
          sendFailureEmail GIT_COMMIT_EMAIL
      }
  }

}

//ObtenciÃ³n versiÃ³n a partir del package.json
def String getversion (file){
    packageJson = readJSON file: file
    return packageJson.version


}

def String getIdProduct(){
  return "PIPEFY"
}

//Obtener entorno para el synth en funciÃ³n de la rama
def String getSynthEnv(){
    
    def environment=""

    if (env.BRANCH_NAME.startsWith('release') || env.BRANCH_NAME.startsWith('hotfix') ){
          environment='INT' // rc y hf
    } else if (env.BRANCH_NAME.startsWith('feature/')) { 
          environment='DEV'
    } else if (env.BRANCH_NAME=='develop')  {
          environment='DEV' // para develop deberia ser INT pero como es V2 y , de momento no se utiliza, apuntamos a DEV
    } else if (env.BRANCH_NAME=='homolog')  {
          environment='INT' // para homolog deberia ser HML pero como no tenemos, apuntamos a INT
    } else if (env.BRANCH_NAME=='master')   {
          environment='PRO' //master para release x.y.z
    } 

    return environment
}

def validateAspects() {
    
    sh """            

    
    app="\$(grep -c 'App()' bin/app.ts | cut -d ' ' -f2)"
    aspects="\$(grep -c 'MARValidation(' bin/app.ts)"
    comment="\$(grep -w 'MARValidation(' bin/app.ts | cut -c 1-2)"
    openComment="\$(grep -B200 'MARValidation(' bin/app.ts | grep '/\\*' -c)"
    closeComment="\$(grep -B200 'MARValidation(' bin/app.ts | grep '\\*/' -c)"
    
    if [ \$app == 0 ];
    then 
        echo "ERROR: There is no cdk app line" 
        error "ERROR: Aspects"
    elif [ \$app -gt 1 ];
    then 
        echo "ERROR: There are more than 1 aplication" 
        error "ERROR: Aspects"
    fi
    
    if [ \$aspects != 1 ];
    then 
        echo "ERROR: There is no aspect validation line" 
        error "ERROR: Aspects"
    fi
    
    if [ \$comment == "//" ];
    then 
        echo "ERROR: Aspects are commented" 
        error "ERROR: Aspects"
    else 
        echo "Aspects are included"
    fi

    if [ \$openComment -gt \$closeComment ];
    then 
        echo "ERROR: Aspects are commented"
        error "ERROR: Aspects"
    fi

    """    
}

def cdkSynth() {
    sh """
    cdk synth -c env=$ENVIRONMENT --all             
    """    
}